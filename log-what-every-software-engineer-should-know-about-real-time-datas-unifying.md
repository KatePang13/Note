# Log：程序员应当知道的实时数据统一抽象

origin:  [The Log: What every software engineer should know about real-time data's unifying abstraction](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)

我在 LinkedIn 度过了很愉快的六年时光。那时我们开始遇到单体中心数据库的局限性，有了向分布式系统演进的需要。这是一段精彩的经历：我们构建，部署了多个分布式系统并一直运行到了今天，包括一个分布式图像数据库，一个分布式搜索后端，一个 Hodoop 安装，一个 一代二代 KV 存储。

从这段经历中，我学到的最有用的东西之一是，我们所构建的很多东西的核心都是基于一个非常简单的概念：log。有时我们称之为 write-ahead log 或者 transaction log。 log 几乎伴随这计算机的诞生而诞生，许多分布式数据系统和实时应用架构的核心都是log。

如果你不理解 log，你就不可能完全理解 数据库，NoSQL, KV 存储，复制，PAXOS, hadoop，版本控制，甚至是任何的软件系统；然而，大多数对 log 都不是很熟悉。我希望改变这个现状，在本文中，我将带你逐步了解log相关的所有知识，包括：什么是log；如何使用log进行数据集成，实时处理和系统构建。



## Part 1：什么是Log?

日志或许是最简单的存储抽象。它是 append-only 的，按时间排序的record序列。看起来像这样：

![img](https://content.linkedin.com/content/dam/engineering/en-us/blog/migrated/log.png)

record被逐一append到日志的结尾，读操作从左到右依次处理。每个 entry 都会分配一个 唯一序列编号 log entry number。

record的顺序定义了时间的概念，左边的entry比右边的entry更早发生。log entry number 可以理解为这个entry的时间戳。将这个顺序描述成时间的概念一开始会有点奇怪，但是它很方便，与任何特定的物理时钟没有之间关联，在分布式系统中，这个特性将变得至关重要。

record 的内容和格式对于此讨论而言并不重要。另外，我们不可能一直向日志中添加记录，因为空间总是会耗尽的。这个后续我会再深入。

所以，日志与文件和表格并没有本质的区别，文件是保存bytes的序列，表格是保存记录的序列，日志其实就是一个文件或者表格，只是记录必须以时序排列。

这里我们可能会疑惑，为什么要讨论一个这么简单的东西。append-only 记录序列是与数据系统有什么关联呢？答案是，日志有一个特定的目的：记录 在什么时候发生了什么（ what happened and when）。对于分布式数据系统，很多时候这都是问题的关键。

在展开讨论之前，我要先澄清一个疑惑。程序员都对另一种日志很熟悉——无结构的错误信息或者应用的追踪信息，使用syslog/log4j 写入到本地文件。为了区分，我将这种日志成为应用程序日志。应用程序日志是我正在描述的日志概念的退化形式。最大的区别在与，文本日志主要是供人类阅读的，而本文讨论的 "journal" 或者 ”data logs“ 是供程序访问的。

（实际上，如果您考虑一下，人类在单台计算机上读取日志的想法已经是不合时宜的了。当涉及到许多服务和服务器时，这种方法很快就变得难以管理，日志的目的迅速转变成了查询和图形的输入，以了解许多机器上的行为——对于这种目的，文件中的文本信息就没有此处描述的那种结构化日志来的合适了）

### Logs in databases

我不知道log概念的起源——或许它就像二分查找那样，看起来过于简单，以至于发明者并没有留意到这是一个发明。它最早出现在IBM的  [System R](http://www.cs.berkeley.edu/~brewer/cs262/SystemR.pdf) 。在数据库中的使用与出现崩溃时保持各种数据结构和索引的同步有关。为了使其具有原子性和持久性，数据库在将更改作用到它数据结构之前，使用日志写出它们将要修改的记录的信息。日志是发生的情况的记录，每个表或索引都是对这个记录的投影。由于日志会立即保留，因此在发生崩溃时，该日志将用作还原所有其他持久性结构的权威来源。

随着时间的流逝，日志的使用从ACID的实现细节发展为在数据库之间复制数据的方法。事实证明，数据库上发生的更改顺序正是保持远程副本数据库同步所需的。 Oracle，MySQL和PostgreSQL包含日志传送协议，以将日志的一部分传输到充当从属的副本数据库。  Oracle已将日志产品化为常规数据订阅机制，提供给非Oracle数据订阅者的 [XStreams](http://docs.oracle.com/cd/E11882_01/server.112/e16545/xstrm_intro.htm)和 [GoldenGate](http://www.oracle.com/technetwork/middleware/goldengate/overview/index.html) 使用，MySQL和PostgreSQL中的类似功能是许多数据体系结构的关键组件。

由于这个起源，机器可读日志的概念在很长一段时间里都局限于数据库内部。使用日志作为数据订阅机制几乎是偶然的。但是，这种非常抽象的方法非常适合支持各种消息传递，数据流和实时数据处理。

### Logs in distributed systems

日志解决的两个问题，序列化变更和分发数据，这在分布式数据系统中显得更为重要。这些分布式系统的核心设计问题之一是对更新顺序达成共识（或者对不一致产生共识并应对这些副作用）。（Agreeing upon an ordering for updates (or agreeing to disagree and coping with the side-effects) are among the core design problems for these systems.）

以日志为中心的分布式系统方法源自一个简单的观察，我将其称为状态机复制原理：

如果2个相同的，确定性的进程，开始于一个相同状态，并且以相同的顺序接收相同的输入，它们将产生相同的输出，并结束于相同的状态。（If two identical, deterministic processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.）

确定性（[Deterministic](http://en.wikipedia.org/wiki/Deterministic_algorithm) ) 表示这个进程是 无时间无关的，不会有任何其他的输入影响其结果。例如，如果一个程序，其输出受线程执行的特定顺序影响，或调用gettimeofday，或某些其他不可重复的东西影响，通常认为是 不确定性的 （non-deterministic）。

进程的状态指的是在处理结束时计算机上保留在内存和磁盘中的任何数据。

**以相同的顺序获得相同的输入**—— 这就是日志的来源。这是一个非常直观的概念：如果对两个确定性代码段输入相同的输入日志，则它们将产生相同的输出。

分布式计算的应用非常明显。您可以将**让多台计算机执行相同操作**，转化成 **实现分布式一致日志以供这些进程输入**。此处日志的目的是从输入流中挤出所有不确定性，以确保处理此输入的每个副本保持同步。

当您理解它时，就会发现这个原理并没有什么复杂或深奥的：它大体的意思就是“**确定性的处理是确定性的**”（**"deterministic processing is deterministic"**）。尽管很简单，我认为它是用于分布式系统设计的通用的工具之一。

这种方法的优点之一是：索引日志的时间戳现在充当了副本状态的时钟——你可以用一个数字来描述每个副本，即已处理的最大日志entry的时间戳。该时间戳与日志相结合，可以独一无二地捕捉这个副本的完整状态。

有多种方法可以根据日志中的内容在系统中应用此原理。例如，我们可以在日志中记录服务请求，或者服务响应于请求而经历的状态更改，或者它执行的转换命令。从理论上讲，我们甚至可以记录一系列机器指令，以便每个副本执行或在每个副本上调用方法名称和参数。只要两个进程以相同的方式处理这些输入，这些进程将在副本之间保持一致。

分布式系统文献通常区分两种主要的处理和复制方法。 “状态机模型”通常是指主动-主动模型（active-active model），其中我们记录传入请求的日志，每个副本处理每个请求。对此的略微修改（称为“主备份模型” ，primary-backup model）是选择一个副本作为领导者，并允许该领导者按请求到达的顺序处理请求，并从处理请求中注销对其状态的更改。领导者进行的状态更改按顺序到应用其他副本，，以便它们同步并准备在领导者失败时接任领导者。

![img](https://content.linkedin.com/content/dam/engineering/en-us/blog/migrated/active_and_passive_arch.png)

要了解这两种方法之间的区别，让我们看一个示例问题。考虑一个复制的“算术服务”，该服务将单个数字作为其状态（初始化为零）并将该值进行加法和乘法。主动-主动方法可能会注销要应用的转换，例如“ +1”，“ * 2”等。每个副本都将应用这些转换，因此要经过相同的一组值。 “主动-被动”方法将使单个主机执行转换并注销结果，例如“ 1”，“ 3”，“ 6”等。此示例还清楚说明了为什么排序对于确保副本之间的一致性至关重要：对加法和乘法进行重新排序将产生不同的结果。

![img](https://content.linkedin.com/content/dam/engineering/en-us/blog/migrated/paxos_postcard.jpg)

分布式日志可以看作是建模共识问题的数据结构。毕竟，日志代表对要附加的“下一个”值的一系列决策。你必须绕以下弯才能看到Paxos系列算法中的日志，尽管日志构建是它们最常见的实际应用。对于Paxos，通常使用协议的扩展名“ multi-paxos”来完成此操作，该协议将日志建模为一系列共识问题，每个问题对应一个日志。日志在[ZAB](http://www.stanford.edu/class/cs347/reading/zab.pdf), [RAFT](https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf), and [Viewstamped Replication](http://pmg.csail.mit.edu/papers/vr-revisited.pdf) 等其他协议中更为突出，这些协议直接对维护分布式一致日志的问题进行建模。

我的怀疑是，我们对此的看法在一定程度上受到了历史道路的误导，这也许是由于几十年来分布式计算的理论超过了其实际应用。实际上，共识问题有点太简单了。计算机系统很少需要确定单个值，它们几乎总是处理一系列请求。因此，使用日志而不是简单的单值寄存器是更自然的抽象。

此外，对算法的关注掩盖了底层日志抽象系统的需求。我有理由怀疑我们最终将把日志作为商品化的构建模块而不管其实现如何，就像我们经常谈论哈希表一样，而不必费心弄清楚是线性探测还是杂项哈希的细节其他变体。日志将变成商品化的接口，许多算法和实现会相互竞争以提供最佳的保证和最佳的性能。



### Changelog 101: Tables and Events are Dual

让我们回到数据库。变更日志和表格之间有一个令人着迷的对偶。该日志类似于所有贷方和借方以及银行流程的列表。表格是所有当前帐户余额。如果有更改日志，则可以应用这些更改以创建捕获当前状态的表。该表将记录每个键的最新状态（以特定的日志时间为准）。从某种意义上说，日志是更基本的数据结构：除了创建原始表之外，您还可以对其进行转换以创建各种派生表。 （是的，表可以表示非关系人员的键控数据存储。）

![img](https://content.linkedin.com/content/dam/engineering/en-us/blog/migrated/yin-yang.jpg)

反过来，如果您有一个表进行更新，则可以记录这些更改并发布所有更新到该表状态的“更改日志”。此变更日志正是支持近实时副本所需要的。因此，从这个意义上讲，您可以将表和事件看作是互补的：**表支持静态数据，日志捕获更改**。**日志的神奇之处在于，如果它是更改的完整日志，则它不仅保存表的最终版本的内容，而且还允许重新创建可能已经存在的所有其他版本。实际上，它是对表的每个先前状态的一种备份**。

这可能使您想起源代码版本控制。源代码管理与数据库之间有着密切的关系。**版本控制解决了与分布式数据系统必须解决的问题非常相似的问题——管理状态的分布式并发更改**。版本控制系统通常对补丁序列进行建模，实际上就是日志。您可以直接与类似于表的当前代码的已签出“快照”相互作用。您会注意到，在版本控制系统中，就像在其他分布式有状态系统中一样，复制是通过日志进行的：更新时，您仅下拉补丁并将其应用到当前快照。

最近有人从 [Datomic](http://www.datomic.com/)（一家以日志为中心的数据库销售公司）看到了其中一些想法。此演示文稿很好地概述了他们如何在系统中应用该想法。当然，这些想法并不是该系统独有的，因为它们成为分布式系统和数据库文献的一部分已有十多年了。

这看起来似乎有点理论性。不要绝望！我们将很快介绍实用的内容。

### What's next

在本文的其余部分中，我将尝试介绍一种日志所不具备的优点，它超出了分布式计算或抽象分布式计算模型的内部范围。这包括： 

- **数据集成**——使组织的所有数据可以轻松地在其所有存储和处理系统中使用。 
- **实时数据处理**——计算派生数据流。 
- **分布式系统设计**——以日志为中心的设计如何简化实际系统。 

这些都围绕着**将日志作为独立服务的思想**来解决。 在每种情况下，**日志的实用性都来自日志提供的简单功能：生成持久的，可重播的历史记录**。出乎意料的是，这些问题的核心是能够以确定的方式以自己的速率使许多计算机回放历史记录。



## Part Two: 数据集成



## Part Three: 日志 与 实时流数据处理



## Part Four: 系统构建



## The End

